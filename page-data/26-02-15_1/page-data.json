{"componentChunkName":"component---src-templates-blog-template-js","path":"/26-02-15_1/","result":{"data":{"cur":{"id":"0dfe15fa-7a6e-5ab9-8ce0-881477c61b57","html":"<p>참고 : 테디노트의 RAG 비법노트 (<a href=\"https://fastcampus.co.kr/data_online_teddy)\">https://fastcampus.co.kr/data_online_teddy)</a><br>소스코드: <a href=\"https://github.com/teddylee777/langchain-kr\">https://github.com/teddylee777/langchain-kr</a><br>위키독스: <a href=\"https://wikidocs.net/book/14314\">https://wikidocs.net/book/14314</a></p>\n<p> </p>\n<p>오늘은 LangGraph 기능들 좀 더 알아보고자 합니다.<br>[26-01-17 게시글][<a href=\"https://byeonwoojung.github.io/26-01-17_1/%5D%EC%97%90%EC%84%9C\">https://byeonwoojung.github.io/26-01-17_1/]에서</a> 좀 얘기를 하긴 했었지만 너무 줄줄이 적어나간 글인 것 같아 오늘은 좀 더 정리해서 올리고자 합니다.</p>\n<p> </p>\n<h2 id=\"human-in-the-loop\" style=\"position:relative;\"><a href=\"#human-in-the-loop\" aria-label=\"human in the loop permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Human-in-the-loop</h2>\n<hr>\n<p>3가지만 기억합시다.</p>\n<ol>\n<li><strong>HumanRequest 툴과 human_node 노드(실제 실행되는 함수) 생성</strong></li>\n<li><strong>interrupt_before 설정</strong></li>\n<li><strong>그래프 상태 업데이트 &#x26; 계속 호출</strong></li>\n</ol>\n<p> </p>\n<h3 id=\"humanrequest-툴과-human_node-노드실제-실행되는-함수-생성\" style=\"position:relative;\"><a href=\"#humanrequest-%ED%88%B4%EA%B3%BC-human_node-%EB%85%B8%EB%93%9C%EC%8B%A4%EC%A0%9C-%EC%8B%A4%ED%96%89%EB%90%98%EB%8A%94-%ED%95%A8%EC%88%98-%EC%83%9D%EC%84%B1\" aria-label=\"humanrequest 툴과 human_node 노드실제 실행되는 함수 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HumanRequest 툴과 human_node 노드(실제 실행되는 함수) 생성</h3>\n<p>HumanRequest는 LLM에게 docstring을 주는 방식으로 작성합시다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> pydantic <span class=\"token keyword\">import</span> BaseModel\n\n<span class=\"token comment\"># 전문가의 도움이 필요할 때 적절한 가이드를 요청할 수 있는 클래스</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">HumanRequest</span><span class=\"token punctuation\">(</span>BaseModel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"Forward the conversation to an expert. Use when you can't assist directly or the user needs assistance that exceeds your authority.\n    To use this function, pass the user's 'request' so that an expert can provide appropriate guidance.\n    \"\"\"</span>\n\n    request<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span>\n    </code></pre></div>\n<p>이후, tools에 HumanRequest를 추가해주고 LLM에게 바인드해줍시다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> langchain_openai <span class=\"token keyword\">import</span> ChatOpenAI\n\n<span class=\"token comment\"># 도구 추가</span>\ntool <span class=\"token operator\">=</span> TavilySearch<span class=\"token punctuation\">(</span>max_results<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 도구 목록 추가(HumanRequest 도구)</span>\ntools <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>tool<span class=\"token punctuation\">,</span> HumanRequest<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># LLM 추가</span>\nllm <span class=\"token operator\">=</span> ChatOpenAI<span class=\"token punctuation\">(</span>model<span class=\"token operator\">=</span><span class=\"token string\">\"gpt-4o-mini\"</span><span class=\"token punctuation\">,</span> temperature<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 도구 바인딩</span>\nllm_with_tools <span class=\"token operator\">=</span> llm<span class=\"token punctuation\">.</span>bind_tools<span class=\"token punctuation\">(</span>tools<span class=\"token punctuation\">)</span>\n\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">chatbot</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">:</span> State<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># LLM 도구 호출을 통한 응답 생성</span>\n    response <span class=\"token operator\">=</span> llm_with_tools<span class=\"token punctuation\">.</span>invoke<span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">[</span><span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\"># 사람에게 질문할지 여부 초기화</span>\n    ask_human <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span>\n\n    <span class=\"token comment\"># 도구 호출이 있고 이름이 'HumanRequest' 인 경우 (여기서는 툴 중에 1번째만 가져옴)</span>\n    <span class=\"token keyword\">if</span> response<span class=\"token punctuation\">.</span>tool_calls <span class=\"token keyword\">and</span> response<span class=\"token punctuation\">.</span>tool_calls<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> HumanRequest<span class=\"token punctuation\">.</span>__name__<span class=\"token punctuation\">:</span>\n        ask_human <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n\n    <span class=\"token comment\"># 메시지와 ask_human 상태 반환</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>response<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ask_human\"</span><span class=\"token punctuation\">:</span> ask_human<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그리고,</p>\n<p>response의 툴 호출이 있을 때 그 이름이 HumanRequest이면 ask_human 상태값을 True로 바꾸도록 합시다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 상태 그래프 초기화</span>\ngraph_builder <span class=\"token operator\">=</span> StateGraph<span class=\"token punctuation\">(</span>State<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 챗봇 노드 추가</span>\ngraph_builder<span class=\"token punctuation\">.</span>add_node<span class=\"token punctuation\">(</span><span class=\"token string\">\"chatbot\"</span><span class=\"token punctuation\">,</span> chatbot<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 도구 노드 추가</span>\ngraph_builder<span class=\"token punctuation\">.</span>add_node<span class=\"token punctuation\">(</span><span class=\"token string\">\"tools\"</span><span class=\"token punctuation\">,</span> ToolNode<span class=\"token punctuation\">(</span>tools<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span>tool<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>그래프 빌더에 상태 초기화, 챗봇과 도구 노드를 추가해준 후에</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> langchain_core<span class=\"token punctuation\">.</span>messages <span class=\"token keyword\">import</span> AIMessage<span class=\"token punctuation\">,</span> ToolMessage\n\n\n<span class=\"token comment\"># 응답 메시지 생성(ToolMessage 생성을 위한 함수) -> 사람이 아무 응답을 하지 않는 경우에 이용하기 위함</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">create_response</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">,</span> ai_message<span class=\"token punctuation\">:</span> AIMessage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> ToolMessage<span class=\"token punctuation\">(</span>\n        content<span class=\"token operator\">=</span>response<span class=\"token punctuation\">,</span>\n        tool_call_id<span class=\"token operator\">=</span>ai_message<span class=\"token punctuation\">.</span>tool_calls<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"id\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span>\n\n\n<span class=\"token comment\"># 인간 노드 처리</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">human_node</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">:</span> State<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    new_messages <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> <span class=\"token builtin\">isinstance</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">[</span><span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> ToolMessage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># ‼️ 사람으로부터 응답이 없는 경우 ‼️</span>\n        new_messages<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>\n            create_response<span class=\"token punctuation\">(</span><span class=\"token string\">\"No response from human.\"</span><span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">[</span><span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\"># 새 메시지 추가</span>\n        <span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">:</span> new_messages<span class=\"token punctuation\">,</span>  <span class=\"token comment\"># 사람으로부터 응답을 받았으면 추가하지 않음</span>\n        <span class=\"token comment\"># 플래그 해제</span>\n        <span class=\"token string\">\"ask_human\"</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n\n\n<span class=\"token comment\"># 그래프에 인간 노드 추가</span>\ngraph_builder<span class=\"token punctuation\">.</span>add_node<span class=\"token punctuation\">(</span><span class=\"token string\">\"human\"</span><span class=\"token punctuation\">,</span> human_node<span class=\"token punctuation\">)</span></code></pre></div>\n<p>human_node를 정의해줍시다.</p>\n<ol>\n<li>\n<p><code class=\"language-text\">human_node</code>는 <code class=\"language-text\">chatbot</code>이 <code class=\"language-text\">HumanReqeust</code>라는 도구를 호출하고자 할 때 사람에게 입력을 받은 후에 이루어집니다. <strong>즉, 사람에게 입력 받은 값이 가장 마지막 값에 들어가 있는 거죠.</strong></p>\n</li>\n<li>\n<p><strong>그러면 <code class=\"language-text\">human_node</code>에서 입력을 안 받는 것인데, 이것은 무엇이냐?</strong></p>\n<blockquote>\n<p><strong>human_node 이전에 interrupt해서 값을 받아서 메시지에 넣어두고,</strong></p>\n<p><strong>human_node에서는 사람의 응답을 처리하거나 보정합니다. (ex. 빈 값이면 “No response from human.”으로 변경 등)</strong></p>\n</blockquote>\n</li>\n<li>\n<p><code class=\"language-text\">create_response</code> 함수를 이용해서 툴 메시지에 tool_call_id와 사람의 답변(response)를 넣도록 합시다. 이 함수를 이용해서 <code class=\"language-text\">human_node</code>에서 상태 값을 보정하는 것을 <code class=\"language-text\">ToolMessage</code> 형태로 변환되도록 합시다.</p>\n</li>\n</ol>\n<p> </p>\n<p>그리고 <strong>인간 노드 관련 조건부 엣지</strong>를 추가해줍시다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> langgraph<span class=\"token punctuation\">.</span>graph <span class=\"token keyword\">import</span> END\n<span class=\"token keyword\">from</span> langgraph<span class=\"token punctuation\">.</span>prebuilt <span class=\"token keyword\">import</span> tools_condition\n\n\n<span class=\"token comment\"># ‼️ 다음 노드 선택 ‼️</span>\n<span class=\"token comment\"># 인간에게 질문하는 것 있을 때는 state[\"ask_human\"]이 true이면 human 노드로 반환함</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">select_next_node</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">:</span> State<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 인간에게 질문 여부 확인</span>\n    <span class=\"token keyword\">if</span> state<span class=\"token punctuation\">[</span><span class=\"token string\">\"ask_human\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"human\"</span>\n    <span class=\"token comment\"># 이전과 동일한 경로 설정</span>\n    <span class=\"token keyword\">return</span> tools_condition<span class=\"token punctuation\">(</span>\n        state\n    <span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 현재 state[\"messages\"]의 마지막 메시지를 보고 AIMessage.tool_calls 있으면 tools, 없으면 END(__end__)를 반환</span>\n\n\n<span class=\"token comment\"># 조건부 엣지 추가 (문자열 보고 노드로 이동)</span>\ngraph_builder<span class=\"token punctuation\">.</span>add_conditional_edges<span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"chatbot\"</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\"># 출발 노드</span>\n    select_next_node<span class=\"token punctuation\">,</span>  <span class=\"token comment\"># 분기 함수(state -> 라벨)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token string\">\"human\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"human\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"tools\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"tools\"</span><span class=\"token punctuation\">,</span>\n        END<span class=\"token punctuation\">:</span> END<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\"># select_next_node가 human 반환하면 human 노드로, tools 반환하면 tools 노드로, 그외 END (종료)</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">select_next_node</code>에서는 현재 <code class=\"language-text\">ask_human</code> 상태 값이 true이면 <code class=\"language-text\">human</code>(human_node 이름)를 반환하고, 아니면 현재 상태(<code class=\"language-text\">tools</code> 또는 <code class=\"language-text\">END</code>) 이름을 반환합니다. (반환은 단순히 문자열임)</p>\n<p>(tools_condition와 같은 LangGraph에서 제공하는 라우팅 함수 말고 직접 구현도 가능합니다.)</p>\n<p>그리고 그 함수를 이용해서</p>\n<ol>\n<li><code class=\"language-text\">chatbot</code>에서 출발해서</li>\n<li><code class=\"language-text\">select_next_node</code> 분기 함수의 값이</li>\n<li>human이면 <code class=\"language-text\">human</code> 노드로, tools이면 <code class=\"language-text\">tools</code> 노드(액션노드)로, END이면 <code class=\"language-text\">END</code> 노드로 보내도록 <strong>조건부 엣지</strong>를 추가합니다.</li>\n</ol>\n<p> </p>\n<h3 id=\"interrupt_before-설정\" style=\"position:relative;\"><a href=\"#interrupt_before-%EC%84%A4%EC%A0%95\" aria-label=\"interrupt_before 설정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>interrupt_before 설정</h3>\n<p>다음은 각 엣지들 추가한 후에 메모리 체크포인터와 human 노드에서 Interrupt를 걸어둡시다.<br>이때 interrupt_before로 걸어둡시다!</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 엣지 추가: 'tools'에서 'chatbot'으로</span>\ngraph_builder<span class=\"token punctuation\">.</span>add_edge<span class=\"token punctuation\">(</span><span class=\"token string\">\"tools\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"chatbot\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 엣지 추가: 'human'에서 'chatbot'으로</span>\ngraph_builder<span class=\"token punctuation\">.</span>add_edge<span class=\"token punctuation\">(</span><span class=\"token string\">\"human\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"chatbot\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 엣지 추가: START에서 'chatbot'으로</span>\ngraph_builder<span class=\"token punctuation\">.</span>add_edge<span class=\"token punctuation\">(</span>START<span class=\"token punctuation\">,</span> <span class=\"token string\">\"chatbot\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 메모리 저장소 초기화</span>\nmemory <span class=\"token operator\">=</span> MemorySaver<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 그래프 컴파일: 메모리 체크포인터 사용</span>\n<span class=\"token comment\"># ‼️‼️ 그래프 컴파일할 떄 interrupt_before를 걸어두기 ‼️‼️</span>\ngraph <span class=\"token operator\">=</span> graph_builder<span class=\"token punctuation\">.</span><span class=\"token builtin\">compile</span><span class=\"token punctuation\">(</span>\n    checkpointer<span class=\"token operator\">=</span>memory<span class=\"token punctuation\">,</span>\n    <span class=\"token comment\"># 'human' 이전에 인터럽트 설정</span>\n    interrupt_before<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"human\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\"># ‼️ human 노드애서 인터럽트 ‼️</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>그래프 빌더를 컴파일할 때 메모리와 인터럽트를 설정 가능합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> langchain_teddynote<span class=\"token punctuation\">.</span>graphs <span class=\"token keyword\">import</span> visualize_graph\n\nvisualize_graph<span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">)</span></code></pre></div>\n<p>그래프 출력해보면</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 708px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 68.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACEUlEQVQ4y5WTb2/SUBjF+2184yfw4/iRTMxemcwXM5nT+MY/ccaxjc0VN5bNGMmADQa0FCi0pX/obW/7M72IYYOYeZKTPrk5Pc95nt5qk8mEh9B1HHqjIfW+wWXzilr3ltbQWtFp/AdcmdDxHar1nzQGBpaYrWi0PM95KGWWEaQJXjzDTwSxTOGe5p8JF6JFvYDvOJCtnquE9w2WjZZZYBCHXHo2unnLhTOk7jvrE657+U6jP8/CYKta5uXBJ17sf+TAbK1Moq01KPYlJWmaIoQgiiLEbEbbc6iMDPaua5xYHc6sHp7r3nlPWzZIkkQZJGmq6kQIZSpTqUZbwB6PieKYLMtUszAMlV4lzPIckabEQqivuEhcnI89lygRSCDJM8VQxEQiJs9y1WyBwPdVU+3OkpbQnQXsGy0qQwN90FX8bpuKZxOLsLgyWY7ruiRSEsyi+ciH4z4btSrPf1R4178hTOfRG1OH8thEt0229RKbe+/58OucU2/EN9vETWKluxgYlM02R/02tekY7en5Vx7tbPB46xlPSq9phVMlbAYuZavDce+Gk34H3epybLQpd5roIwMvEUpXnQzYPP7C5tEup7aJZscRV75DPXDphtO/O2z4Dp+Na7ZPD3lVKfH2ssKbixO29BK7t1dM5Xx/vcinHno0Qk/V2rorU2AUR2qE62hKs2DozVnUgUss5dq/6zf7wytsq5KuiAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"img 1\" title=\"img 1\" src=\"/static/c782591e791e65cf4a18191ea144524f/3cb0f/img_1.png\" srcset=\"/static/c782591e791e65cf4a18191ea144524f/e9ff0/img_1.png 180w,\n/static/c782591e791e65cf4a18191ea144524f/f21e7/img_1.png 360w,\n/static/c782591e791e65cf4a18191ea144524f/3cb0f/img_1.png 708w\" sizes=\"(max-width: 708px) 100vw, 708px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<p>이런 식으로 human_interrupt를 통해 human 노드에 조건부 엣지가 생겨있음을 확인할 수 있습니다.</p>\n<p> </p>\n<h3 id=\"그래프-상태-업데이트--계속-호출\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9E%98%ED%94%84-%EC%83%81%ED%83%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8--%EA%B3%84%EC%86%8D-%ED%98%B8%EC%B6%9C\" aria-label=\"그래프 상태 업데이트  계속 호출 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그래프 상태 업데이트 &#x26; 계속 호출</h3>\n<p>먼저 config에 configurable의 쓰레드 ID를 설정해준 상태에서 <code class=\"language-text\">stream_mode</code>은 <code class=\"language-text\">values</code>로 설정하여<br>user 메시지에 input값을 넣어 stream으로 호출해봅시다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># user_input = \"이 AI 에이전트를 구축하기 위해 전문가의 도움이 필요합니다. 검색해서 답변하세요\" (Human 이 아닌 웹검색을 수행하는 경우)</span>\nuser_input <span class=\"token operator\">=</span> <span class=\"token string\">\"이 AI 에이전트를 구축하기 위해 전문가의 도움이 필요합니다. 도움을 요청할 수 있나요?\"</span>\n\n<span class=\"token comment\"># config 설정</span>\nconfig <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"configurable\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"thread_id\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\"># 스트림 또는 호출의 두 번째 위치 인수로서의 구성</span>\nevents <span class=\"token operator\">=</span> graph<span class=\"token punctuation\">.</span>stream<span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">{</span><span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"user\"</span><span class=\"token punctuation\">,</span> user_input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> config<span class=\"token punctuation\">,</span> stream_mode<span class=\"token operator\">=</span><span class=\"token string\">\"values\"</span>\n<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span> event <span class=\"token keyword\">in</span> events<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> <span class=\"token string\">\"messages\"</span> <span class=\"token keyword\">in</span> event<span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 마지막 메시지의 예쁜 출력</span>\n        event<span class=\"token punctuation\">[</span><span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>pretty_print<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token triple-quoted-string string\">\"\"\"출력:\n================================\u001b[1m Human Message \u001b[0m=================================\n\n이 AI 에이전트를 구축하기 위해 전문가의 도움이 필요합니다. 도움을 요청할 수 있나요?\n==================================\u001b[1m Ai Message \u001b[0m==================================\nTool Calls:\n  HumanRequest (call_KNeSo6khmAxmGlh4wLlTmY97)\n Call ID: call_KNeSo6khmAxmGlh4wLlTmY97\n  Args:\n    request: AI 에이전트를 구축하는 데 필요한 전문가의 도움을 요청합니다. 구체적으로 어떤 기술 스택과 방법론이 필요한지, 그리고 프로젝트를 시작하기 위한 단계에 대한 조언이 필요합니다.\n\"\"\"</span></code></pre></div>\n<p>for문으로 롤링할 때, 각 event에서 messages가 존재할 때 가장 마지막 메시지(최신 메시지)만 출력하는 코드입니다.</p>\n<p>아직 Tool을 호출하지 않은 상태네요. (ToolMessage가 아님)</p>\n<p>현재 chatbot은 HumanRequest 툴을 request 인자 값을 채워 호출을 준비하고 있는데,</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 그래프 상태 스냅샷 생성</span>\nsnapshot <span class=\"token operator\">=</span> graph<span class=\"token punctuation\">.</span>get_state<span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 다음 스냅샷 상태 접근</span>\nsnapshot<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n<span class=\"token triple-quoted-string string\">\"\"\"출력: ('human',)\"\"\"</span></code></pre></div>\n<p>위 코드로 현재 다음 노드를 확인하면 <code class=\"language-text\">human</code>임을 확인할 수 있습니다.<br>즉, human을 호출하기 직전에 interrupt 되어 있는 것을 확인할 수 있습니다.</p>\n<p>그러면</p>\n<p><strong>그 다음 할 일은 <code class=\"language-text\">ToolMessage</code>를 직접 채워준 후에 계속해서 호출을 진행하면 됩니다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 가장 마지막 AI 메시지 추출</span>\n<span class=\"token comment\"># -> create_response에서 tool_calls에서 해당 툴 id를 가져올 것임</span>\nai_message <span class=\"token operator\">=</span> snapshot<span class=\"token punctuation\">.</span>values<span class=\"token punctuation\">[</span><span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># 인간 응답 생성</span>\nhuman_response <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"전문가들이 도와드리겠습니다! 에이전트 구축을 위해 LangGraph를 확인해 보시기를 적극 추천드립니다. \"</span>\n    <span class=\"token string\">\"단순한 자율 에이전트보다 훨씬 더 안정적이고 확장성이 뛰어납니다. \"</span>\n    <span class=\"token string\">\"https://wikidocs.net/233785 에서 더 많은 정보를 확인할 수 있습니다.\"</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 도구 메시지 생성 (content에 human_response 넣고, tool_call_id에 ai_message에서 해당 툴 id 가져옴)</span>\ntool_message <span class=\"token operator\">=</span> create_response<span class=\"token punctuation\">(</span>human_response<span class=\"token punctuation\">,</span> ai_message<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 그래프 상태 업데이트</span>\ngraph<span class=\"token punctuation\">.</span>update_state<span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>tool_message<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>인간의 응답과 가장 마지막 AI 메시지로 인자로 하여 <code class=\"language-text\">create_response</code> 함수를 호출하여<br>각각 <code class=\"language-text\">content</code>와 <code class=\"language-text\">tool_call_id</code> 값을 채워 ToolMessage로 감싸도록 합니다.</p>\n<p>그 이후 <code class=\"language-text\">config</code>와 메시지를 함께 주어 <code class=\"language-text\">update_state</code>를 통해 그래프 상태를 수동으로 업데이트 합니다.</p>\n<p>업데이트 이후 아래와 같이 계속 호출하면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 그래프에서 이벤트 스트림 생성</span>\nevents <span class=\"token operator\">=</span> graph<span class=\"token punctuation\">.</span>stream<span class=\"token punctuation\">(</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span> config<span class=\"token punctuation\">,</span> stream_mode<span class=\"token operator\">=</span><span class=\"token string\">\"values\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 각 이벤트에 대한 처리</span>\n<span class=\"token keyword\">for</span> event <span class=\"token keyword\">in</span> events<span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 메시지가 있는 경우 마지막 메시지 출력</span>\n    <span class=\"token keyword\">if</span> <span class=\"token string\">\"messages\"</span> <span class=\"token keyword\">in</span> event<span class=\"token punctuation\">:</span>\n        event<span class=\"token punctuation\">[</span><span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>pretty_print<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        \n<span class=\"token triple-quoted-string string\">\"\"\"출력:\n=================================\u001b[1m Tool Message \u001b[0m=================================\n\n전문가들이 도와드리겠습니다! 에이전트 구축을 위해 LangGraph를 확인해 보시기를 적극 추천드립니다. 단순한 자율 에이전트보다 훨씬 더 안정적이고 확장성이 뛰어납니다. https://wikidocs.net/233785 에서 더 많은 정보를 확인할 수 있습니다.\n=================================\u001b[1m Tool Message \u001b[0m=================================\n\n전문가들이 도와드리겠습니다! 에이전트 구축을 위해 LangGraph를 확인해 보시기를 적극 추천드립니다. 단순한 자율 에이전트보다 훨씬 더 안정적이고 확장성이 뛰어납니다. https://wikidocs.net/233785 에서 더 많은 정보를 확인할 수 있습니다.\n==================================\u001b[1m Ai Message \u001b[0m==================================\n\n전문가의 추천에 따라, AI 에이전트를 구축하기 위해 LangGraph를 확인해 보시기를 권장합니다. LangGraph는 단순한 자율 에이전트보다 훨씬 더 안정적이고 확장성이 뛰어난 솔루션입니다. 더 많은 정보는 [여기](https://wikidocs.net/233785)에서 확인하실 수 있습니다. 도움이 필요하시면 언제든지 말씀해 주세요!\n\"\"\"</span></code></pre></div>\n<p>(참고로 같은 것이 출력된 것은 <code class=\"language-text\">stream_mode</code>가 <code class=\"language-text\">values</code>이기 때문에 ToolMessage 출력 후, 또 한번의 ToolMessage와 최종 AIMessage가 출력된 것입니다.)</p>\n<p> </p>\n<p> </p>\n<h2 id=\"deletemessages\" style=\"position:relative;\"><a href=\"#deletemessages\" aria-label=\"deletemessages permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DeleteMessages</h2>\n<hr>\n<p>특정 메시지를 삭제하는 방법은 아래와 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> langchain_core<span class=\"token punctuation\">.</span>messages <span class=\"token keyword\">import</span> RemoveMessage\n\n<span class=\"token comment\"># ⭐️ 메시지 배열의 특정 메시지(여기서는 1번째 메시지)를 ID 기반으로 제거하고 앱 상태 업데이트 ⭐️</span>\ngraph<span class=\"token punctuation\">.</span>update_state<span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">:</span> RemoveMessage<span class=\"token punctuation\">(</span><span class=\"token builtin\">id</span><span class=\"token operator\">=</span>messages<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">id</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">update_state</code> 메서드에 현 설정값인 <code class=\"language-text\">config</code>와 <code class=\"language-text\">messages</code> 키 값에 <code class=\"language-text\">RemoveMessage()</code> 객체를 넣어준 딕셔너리를 인자로 주면 됩니다.</p>\n<p>이때, <code class=\"language-text\">RemoveMessage</code>에는 지우고자 하는 특정 메시지의 <code class=\"language-text\">id</code>를 넣어 인스턴스 생성하여 전달합니다.</p>\n<p> </p>\n<h3 id=\"agent가-tool-calling-모두-마쳤을-때-메시지-정리-후-종료하는-그래프-예시\" style=\"position:relative;\"><a href=\"#agent%EA%B0%80-tool-calling-%EB%AA%A8%EB%91%90-%EB%A7%88%EC%B3%A4%EC%9D%84-%EB%95%8C-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%A0%95%EB%A6%AC-%ED%9B%84-%EC%A2%85%EB%A3%8C%ED%95%98%EB%8A%94-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%98%88%EC%8B%9C\" aria-label=\"agent가 tool calling 모두 마쳤을 때 메시지 정리 후 종료하는 그래프 예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Agent가 Tool Calling 모두 마쳤을 때, 메시지 정리 후 종료하는 그래프 예시</h3>\n<p>아래는 Agent의 Tool calliing을 마친 뒤에 메시지 개수가 3개 초과 시, 최신 3개만 유지하는 코드입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> langchain_core<span class=\"token punctuation\">.</span>messages <span class=\"token keyword\">import</span> RemoveMessage\n<span class=\"token keyword\">from</span> typing <span class=\"token keyword\">import</span> Literal\n<span class=\"token keyword\">from</span> langchain_core<span class=\"token punctuation\">.</span>tools <span class=\"token keyword\">import</span> tool\n<span class=\"token keyword\">from</span> langchain_openai <span class=\"token keyword\">import</span> ChatOpenAI\n<span class=\"token keyword\">from</span> langgraph<span class=\"token punctuation\">.</span>checkpoint<span class=\"token punctuation\">.</span>memory <span class=\"token keyword\">import</span> MemorySaver\n<span class=\"token keyword\">from</span> langgraph<span class=\"token punctuation\">.</span>graph <span class=\"token keyword\">import</span> MessagesState<span class=\"token punctuation\">,</span> StateGraph<span class=\"token punctuation\">,</span> START<span class=\"token punctuation\">,</span> END\n<span class=\"token keyword\">from</span> langgraph<span class=\"token punctuation\">.</span>prebuilt <span class=\"token keyword\">import</span> ToolNode<span class=\"token punctuation\">,</span> tools_condition\n\n<span class=\"token comment\"># 체크포인트 저장을 위한 메모리 객체 초기화</span>\nmemory <span class=\"token operator\">=</span> MemorySaver<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token comment\"># 웹 검색 기능을 모방하는 도구 함수 정의</span>\n<span class=\"token decorator annotation punctuation\">@tool</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>query<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"Call to surf on the web.\"\"\"</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">\"웹 검색 결과: LangGraph 한글 튜토리얼은 https://wikidocs.net/233785 에서 확인할 수 있습니다.\"</span>\n\n\n<span class=\"token comment\"># 도구 목록 생성 및 도구 노드 초기화</span>\ntools <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>search<span class=\"token punctuation\">]</span>\ntool_node <span class=\"token operator\">=</span> ToolNode<span class=\"token punctuation\">(</span>tools<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 모델 초기화 및 도구 바인딩</span>\nmodel <span class=\"token operator\">=</span> ChatOpenAI<span class=\"token punctuation\">(</span>model_name<span class=\"token operator\">=</span><span class=\"token string\">\"gpt-4o-mini\"</span><span class=\"token punctuation\">)</span>\nbound_model <span class=\"token operator\">=</span> model<span class=\"token punctuation\">.</span>bind_tools<span class=\"token punctuation\">(</span>tools<span class=\"token punctuation\">)</span>\n\n\n<span class=\"token comment\"># LLM 모델 호출 및 응답 처리 함수</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">call_model</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">:</span> MessagesState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    response <span class=\"token operator\">=</span> bound_model<span class=\"token punctuation\">.</span>invoke<span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">[</span><span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">:</span> response<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token comment\"># ⭐️ 메시지 개수가 3개 초과 시 오래된 메시지 삭제 및 최신 메시지만 유지 ⭐️</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">delete_messages</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    messages <span class=\"token operator\">=</span> state<span class=\"token punctuation\">[</span><span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>messages<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">3</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>RemoveMessage<span class=\"token punctuation\">(</span><span class=\"token builtin\">id</span><span class=\"token operator\">=</span>m<span class=\"token punctuation\">.</span><span class=\"token builtin\">id</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> m <span class=\"token keyword\">in</span> messages<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token operator\">-</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span>\n\n\n<span class=\"token comment\"># 메시지 상태에 따른 다음 실행 노드 결정 로직</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">should_continue</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">:</span> MessagesState<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> Literal<span class=\"token punctuation\">[</span><span class=\"token string\">\"action\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"delete_messages\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"Return the next node to execute.\"\"\"</span>\n    last_message <span class=\"token operator\">=</span> state<span class=\"token punctuation\">[</span><span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># ‼️ 함수 호출이 없는 경우(더 이상 agent가 툴 호출할 것이 없을 때) 메시지 삭제 함수 실행 ‼️</span>\n    <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> last_message<span class=\"token punctuation\">.</span>tool_calls<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"delete_messages\"</span>\n    <span class=\"token comment\"># ‼️ 함수 호출이 있는 경우 액션(툴 호출) 실행 ‼️</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">\"action\"</span>\n\n\n<span class=\"token comment\"># 메시지 상태 기반 워크플로우 그래프 정의</span>\nworkflow <span class=\"token operator\">=</span> StateGraph<span class=\"token punctuation\">(</span>MessagesState<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 에이전트와 액션 노드 추가</span>\nworkflow<span class=\"token punctuation\">.</span>add_node<span class=\"token punctuation\">(</span><span class=\"token string\">\"agent\"</span><span class=\"token punctuation\">,</span> call_model<span class=\"token punctuation\">)</span>\nworkflow<span class=\"token punctuation\">.</span>add_node<span class=\"token punctuation\">(</span><span class=\"token string\">\"action\"</span><span class=\"token punctuation\">,</span> tool_node<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 메시지 삭제 노드 추가</span>\nworkflow<span class=\"token punctuation\">.</span>add_node<span class=\"token punctuation\">(</span>delete_messages<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 시작 노드에서 에이전트 노드로 연결</span>\nworkflow<span class=\"token punctuation\">.</span>add_edge<span class=\"token punctuation\">(</span>START<span class=\"token punctuation\">,</span> <span class=\"token string\">\"agent\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 조건부 엣지 추가를 통한 노드 간 흐름 제어</span>\nworkflow<span class=\"token punctuation\">.</span>add_conditional_edges<span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"agent\"</span><span class=\"token punctuation\">,</span>\n    should_continue<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 액션 노드에서 에이전트 노드로 연결</span>\nworkflow<span class=\"token punctuation\">.</span>add_edge<span class=\"token punctuation\">(</span><span class=\"token string\">\"action\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"agent\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 메시지 삭제 노드에서 종료 노드로 연결</span>\nworkflow<span class=\"token punctuation\">.</span>add_edge<span class=\"token punctuation\">(</span><span class=\"token string\">\"delete_messages\"</span><span class=\"token punctuation\">,</span> END<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 메모리 체크포인터를 사용하여 워크플로우 컴파일</span>\napp <span class=\"token operator\">=</span> workflow<span class=\"token punctuation\">.</span><span class=\"token builtin\">compile</span><span class=\"token punctuation\">(</span>checkpointer<span class=\"token operator\">=</span>memory<span class=\"token punctuation\">)</span></code></pre></div>\n<p>간단히 정리하면</p>\n<ol>\n<li><code class=\"language-text\">agent</code> 노드에서 모델을 메시지 상태를 인자로 하여 <code class=\"language-text\">invoke()</code> 메서드로 호출한 후, 메시지 상태를 반환합니다.</li>\n<li><code class=\"language-text\">action</code> 노드는 툴을 모아놓은  <code class=\"language-text\">tool_node</code> (ToolNode)입니다.</li>\n<li><code class=\"language-text\">agent</code>에는 <code class=\"language-text\">should_continue</code> 분기 함수로 조건부 엣지가 있습니다. (메시지 삭제 또는 툴 호출)</li>\n<li><strong><code class=\"language-text\">should_continue</code>는 agent에서 매번 더이상 툴 호출할 것이 있는지 확인하여 있다면 action(툴 호출) 노드, 없다면 delete_messages(메시지 정리) 노드로 이동합니다.</strong></li>\n<li><strong><code class=\"language-text\">delete_messages</code>는 <code class=\"language-text\">state</code>를 인자로 받고, 메시지가 3개 이상이면 <code class=\"language-text\">{\"messages\": [RemoveMessage(id=m.id) for m in messages[:-3]]}</code>를 통해 가장 최신 3개 메시지만 남기고 지우면서 업데이트할 <code class=\"language-text\">messages</code> 상태를 반환합니다.</strong></li>\n</ol>\n<p> </p>\n<p><strong><code class=\"language-text\">should_continue</code>는 라우터 함수로서 이용하고, 이때 노드 이름을 반환하도록 하면 됩니다.<br>그리고 조건부 엣지의 분기 함수로 사용하게 되면 should_continue를 거치면서 계속 툴을 호출할지, 중간에 메시지를 삭제할지, 끝낼지 결정되면 됩니다.</strong></p>\n<p>그러면, 중간에 요약하는 노드도 <code class=\"language-text\">should_continue</code> 라우터에서 분기처리 하면 되겠죠?</p>\n<p> </p>\n<p> </p>\n<h2 id=\"중간-요약-및-메시지-삭제\" style=\"position:relative;\"><a href=\"#%EC%A4%91%EA%B0%84-%EC%9A%94%EC%95%BD-%EB%B0%8F-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%82%AD%EC%A0%9C\" aria-label=\"중간 요약 및 메시지 삭제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>중간 요약 및 메시지 삭제</h2>\n<hr>\n<p>위에서 메시지 삭제하는 노드</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> langgraph<span class=\"token punctuation\">.</span>graph <span class=\"token keyword\">import</span> END\n<span class=\"token keyword\">from</span> langchain_core<span class=\"token punctuation\">.</span>messages <span class=\"token keyword\">import</span> HumanMessage<span class=\"token punctuation\">,</span> AIMessage<span class=\"token punctuation\">,</span> RemoveMessage\n\n\n<span class=\"token comment\"># 대화 종료 또는 요약 결정 로직</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">should_continue</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">:</span> State<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> Literal<span class=\"token punctuation\">[</span><span class=\"token string\">\"summarize_conversation\"</span><span class=\"token punctuation\">,</span> END<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 메시지 목록 확인</span>\n    messages <span class=\"token operator\">=</span> state<span class=\"token punctuation\">[</span><span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token comment\"># 메시지 수가 6개 초과라면 요약 노드로 이동 ‼️</span>\n    <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>messages<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">6</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"summarize_conversation\"</span>\n    <span class=\"token keyword\">return</span> END\n\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">safe_delete_ops</span><span class=\"token punctuation\">(</span>messages<span class=\"token punctuation\">,</span> keep_last_human_turns<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 툴 호출 진행 중이면 정리하지 않음</span>\n    <span class=\"token keyword\">if</span> <span class=\"token builtin\">isinstance</span><span class=\"token punctuation\">(</span>messages<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> AIMessage<span class=\"token punctuation\">)</span> <span class=\"token keyword\">and</span> messages<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>tool_calls<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n    human_idxs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>i <span class=\"token keyword\">for</span> i<span class=\"token punctuation\">,</span> m <span class=\"token keyword\">in</span> <span class=\"token builtin\">enumerate</span><span class=\"token punctuation\">(</span>messages<span class=\"token punctuation\">)</span> <span class=\"token keyword\">if</span> <span class=\"token builtin\">isinstance</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">,</span> HumanMessage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>human_idxs<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;=</span> keep_last_human_turns<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token comment\"># 마지막 N개 human 턴 시작점 이전만 삭제</span>\n    cut <span class=\"token operator\">=</span> human_idxs<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span>keep_last_human_turns<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>RemoveMessage<span class=\"token punctuation\">(</span><span class=\"token builtin\">id</span><span class=\"token operator\">=</span>m<span class=\"token punctuation\">.</span><span class=\"token builtin\">id</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> m <span class=\"token keyword\">in</span> messages<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>cut<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n\n\n<span class=\"token comment\"># 대화 내용 요약 및 메시지 정리 로직</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">summarize_conversation</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">:</span> State<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 이전 요약 정보 확인</span>\n    summary <span class=\"token operator\">=</span> state<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">\"summary\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\"># 이전 요약 정보가 있다면 요약 메시지 생성</span>\n    <span class=\"token keyword\">if</span> summary<span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 지금까지의 대화 요약이다. 위의 새로운 메시지를 고려하여 요약을 확장하라.</span>\n        summary_message <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>\n            <span class=\"token string-interpolation\"><span class=\"token string\">f\"This is summary of the conversation to date: </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>summary<span class=\"token punctuation\">}</span></span><span class=\"token string\">\\n\\n\"</span></span>\n            <span class=\"token string\">\"Extend the summary by taking into account the new messages above in Korean:\"</span>\n        <span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 요약 메시지 생성</span>\n        summary_message <span class=\"token operator\">=</span> <span class=\"token string\">\"Create a summary of the conversation above in Korean:\"</span>\n\n    <span class=\"token comment\"># 이전 메시지에 요약 메시지(HumanMessage로 감쌈)를 결합</span>\n    messages <span class=\"token operator\">=</span> state<span class=\"token punctuation\">[</span><span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">[</span>HumanMessage<span class=\"token punctuation\">(</span>content<span class=\"token operator\">=</span>summary_message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># 모델 호출</span>\n    response <span class=\"token operator\">=</span> model<span class=\"token punctuation\">.</span>invoke<span class=\"token punctuation\">(</span>messages<span class=\"token punctuation\">)</span>\n    \n    delete_messages <span class=\"token operator\">=</span> safe_delete_ops<span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">[</span><span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> keep_last_human_turns<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"summary\"</span><span class=\"token punctuation\">:</span> response<span class=\"token punctuation\">.</span>content<span class=\"token punctuation\">,</span> <span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">:</span> delete_messages<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token comment\"># 워크플로우 그래프 초기화</span>\nworkflow <span class=\"token operator\">=</span> StateGraph<span class=\"token punctuation\">(</span>State<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 대화 및 요약 노드 추가</span>\nworkflow<span class=\"token punctuation\">.</span>add_node<span class=\"token punctuation\">(</span><span class=\"token string\">\"conversation\"</span><span class=\"token punctuation\">,</span> ask_llm<span class=\"token punctuation\">)</span>\nworkflow<span class=\"token punctuation\">.</span>add_node<span class=\"token punctuation\">(</span>summarize_conversation<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 시작점을 대화 노드로 설정</span>\nworkflow<span class=\"token punctuation\">.</span>add_edge<span class=\"token punctuation\">(</span>START<span class=\"token punctuation\">,</span> <span class=\"token string\">\"conversation\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 조건부 엣지 추가</span>\nworkflow<span class=\"token punctuation\">.</span>add_conditional_edges<span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"conversation\"</span><span class=\"token punctuation\">,</span>\n    should_continue<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token string\">\"summarize_conversation\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"summarize_conversation\"</span><span class=\"token punctuation\">,</span>\n        END<span class=\"token punctuation\">:</span> END<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\"># 생략 가능</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 요약 노드에서 종료 노드로의 엣지 추가</span>\nworkflow<span class=\"token punctuation\">.</span>add_edge<span class=\"token punctuation\">(</span><span class=\"token string\">\"summarize_conversation\"</span><span class=\"token punctuation\">,</span> END<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 워크플로우 컴파일 및 메모리 체크포인터 설정</span>\napp <span class=\"token operator\">=</span> workflow<span class=\"token punctuation\">.</span><span class=\"token builtin\">compile</span><span class=\"token punctuation\">(</span>checkpointer<span class=\"token operator\">=</span>memory<span class=\"token punctuation\">)</span>\n</code></pre></div>\n<ol>\n<li>(조건부 엣지 추가)  <code class=\"language-text\">conversation</code>에서 <code class=\"language-text\">should_continue</code> 분기 함수로 조건부 엣지를 추가합니다.</li>\n<li><strong>(노드 라우팅 조건) <code class=\"language-text\">should_continue</code>에서 메시지가 6개 초과하면 <code class=\"language-text\">summarize_conversation</code> 노드로 라우팅합니다.</strong></li>\n<li>(요약) <code class=\"language-text\">summarize_conversation</code>에서 이전 요약이 있다면 요약을 확장하고, 없다면 새롭게 요약을 진행합니다.</li>\n<li><strong>(요약 후 메시지 삭제) <code class=\"language-text\">summarize_conversation</code>에서 요약을 진행한 후, <code class=\"language-text\">safe_delete_ops</code> 함수를 통해 아래의 사항을 지키면서 메시지를 삭제합니다.</strong>\n<ul>\n<li><strong><code class=\"language-text\">AIMessage</code>인 가장 마지막 메시지에서 <code class=\"language-text\">tool_calls</code>가 있다면(툴 호출 진행 중이라면) 정리하지 않음</strong></li>\n<li><strong>2개의 <code class=\"language-text\">HumanMessage</code> 턴만큼만 남기고 삭제한다. (삭제할 것 없을 때는 <code class=\"language-text\">add_message</code> 리듀서라서 []를 반환)</strong></li>\n</ul>\n</li>\n</ol>\n<p> </p>\n<p>조건부 엣지와 노드 라우팅, 상태 업데이트만 잘 고려한다면 쉽게 할 수 있습니다.</p>\n<p> </p>\n<p> </p>\n<p>오늘은 우선 여기까지 쓰고 다음에 나머지를 쓰도록 하겠습니다. 👍🏻</p>\n<p> </p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#human-in-the-loop\">Human-in-the-loop</a></p>\n<ul>\n<li><a href=\"#humanrequest-%ED%88%B4%EA%B3%BC-human_node-%EB%85%B8%EB%93%9C%EC%8B%A4%EC%A0%9C-%EC%8B%A4%ED%96%89%EB%90%98%EB%8A%94-%ED%95%A8%EC%88%98-%EC%83%9D%EC%84%B1\">HumanRequest 툴과 human_node 노드(실제 실행되는 함수) 생성</a></li>\n<li><a href=\"#interrupt_before-%EC%84%A4%EC%A0%95\">interrupt_before 설정</a></li>\n<li><a href=\"#%EA%B7%B8%EB%9E%98%ED%94%84-%EC%83%81%ED%83%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8--%EA%B3%84%EC%86%8D-%ED%98%B8%EC%B6%9C\">그래프 상태 업데이트 &#x26; 계속 호출</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#deletemessages\">DeleteMessages</a></p>\n<ul>\n<li><a href=\"#agent%EA%B0%80-tool-calling-%EB%AA%A8%EB%91%90-%EB%A7%88%EC%B3%A4%EC%9D%84-%EB%95%8C-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%A0%95%EB%A6%AC-%ED%9B%84-%EC%A2%85%EB%A3%8C%ED%95%98%EB%8A%94-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%98%88%EC%8B%9C\">Agent가 Tool Calling 모두 마쳤을 때, 메시지 정리 후 종료하는 그래프 예시</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%A4%91%EA%B0%84-%EC%9A%94%EC%95%BD-%EB%B0%8F-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%82%AD%EC%A0%9C\">중간 요약 및 메시지 삭제</a></p>\n</li>\n</ul>\n</div>","excerpt":"참고 : 테디노트의 RAG 비법노트 (https://fastcampus.co.kr/data_online_teddy)소스코드: https://github.com/teddylee777/langchain-kr위키독스: https://wikidocs.net/book/14314   오늘은 LangGraph 기능들 좀 더 알아보고자 합니다.[26-01-17 게시글][https://byeonwoojung.github.io/26-01-17_1/]에서 좀 얘기를 하긴 했었지만 너무 줄줄이 적어나간 글인 것 같아 오늘은 좀 더 정리해서 올리고자 합니다.   Human-in-the-loop 3가지만 기억합시다. HumanRequest 툴과 human_node 노드(실제 실행되는 함수) 생성 interrupt_before 설정 그래프 상태 업데이트 & 계속 호출   HumanRequest 툴과 human_node 노드(실제 실행되는 함수) 생성 HumanRequest는 LLM에게 docstring을 주…","frontmatter":{"date":"February 15, 2026","title":"[LLM] 테디노트의 RAG 비법노트 끄적끄적-15","categories":"LLM","author":"변우중","emoji":"☀️"},"fields":{"slug":"/26-02-15_1/"}},"next":{"id":"43e4eb72-86c7-5bf4-b823-9d74506fda6f","html":"<p>오늘은 제가 진행하고 있는 프로젝트에서<br><strong>RAG 성능 평가</strong>를 진행했던 부분을 다루고자 합니다.</p>\n<p> </p>\n<p>우선 저는,</p>\n<p><strong>유튜브 콘텐츠의 자동 생성 자막</strong> 등을 이용한<br>Agent 프로젝트 (자세한 건 아직 비밀 🤫)를 진행 중에 있습니다.</p>\n<p>이 데이터를 벡터 임베딩을 통해 RAG 개발을 하고 있는데,<br>개발하면서 했던 여러 고민들을 정리해보고자 합니다.</p>\n<p> </p>\n<h2 id=\"첫번째-고민-asr-오류-어떻게-해결하지\" style=\"position:relative;\"><a href=\"#%EC%B2%AB%EB%B2%88%EC%A7%B8-%EA%B3%A0%EB%AF%BC-asr-%EC%98%A4%EB%A5%98-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EA%B2%B0%ED%95%98%EC%A7%80\" aria-label=\"첫번째 고민 asr 오류 어떻게 해결하지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>첫번째 고민: ASR 오류 어떻게 해결하지?</h2>\n<hr>\n<p><strong>유튜브 콘텐츠 자동 생성 자막</strong>은 <strong>ASR</strong>(Automatic Speech Recognition, 자동 음성 인식)을 통해 만들어지기 때문에 오류가 있습니다.</p>\n<p>이는 주변 배경음이나 발화자의 발음, STT 모델의 성능 등의 이유로 발생하는 오류인데<br>이를 곧바로 RAG 개발에 이용하면 문제가 차암 많아지겠죠.</p>\n<p>그래서 LLM을 이용해 데이터 전처리를 해보자 마음을 먹었습니다.</p>\n<h3 id=\"phase-1-자막-교정-시도해보자\" style=\"position:relative;\"><a href=\"#phase-1-%EC%9E%90%EB%A7%89-%EA%B5%90%EC%A0%95-%EC%8B%9C%EB%8F%84%ED%95%B4%EB%B3%B4%EC%9E%90\" aria-label=\"phase 1 자막 교정 시도해보자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Phase 1. 자막 교정 시도해보자.</h3>\n<p>ASR 오류에서 ”<strong>문자의 형태학적 오류로 인한 의미적 차이를 분명하게 차이가 있었을 때</strong>” 문제가 생깁니다.</p>\n<p><strong>‘꽃게’의 ‘게’를 ‘개’로 인식이 되어 있다면<br>‘꽃게를 먹은 장면을 찾을 때 해당 문서가 검색되지 않을 가능성이 높아집니다.</strong></p>\n<p>이를 해결하고자 ”<strong>LLM을 이용해 자막 교정</strong>“을 시도해보았습니다.</p>\n<p>결론부터 말씀드리면..</p>\n<p>실패 🫨</p>\n<p> </p>\n<p>자막 교정은</p>\n<ol>\n<li>로컬 오픈소스 모델들로 테스트했고 (LLM API는 모든 자막 수정하기에 돈이 많이 듦)</li>\n<li>우선 수정을 정확하게 해주지 않은 부분이 많았고</li>\n<li>필요한 부분만 수정한 후 해당 자막 청크를 그대로 출력도 안해 줬습니다.</li>\n<li>그리고, LLM에게 전체 맥락을 알려주기 위해 해당 영상의 전체 자막과 유튜브 영상 제목 등을 함께 제공해보았지만 3번의 문제가 정말 많이 발생했습니다.</li>\n</ol>\n<p>프롬프트 수정도 많이 해보고 그랬지만<br>오픈소스 소형 모델에게 이걸 시킨다는 시도 자체가 잘못된 것 같아 보였습니다.</p>\n<p>결국,</p>\n<p>어쨌든 모델의 성능 문제인 건데<br>모델을 자막 교정을 잘하도록 Fine-tuning을 해보자..? 하기에는 한국어 교육을 전범위에서 해줘야 하기에 너무 큰 Task가 됩니다.</p>\n<p>그래서 이 방법은 <strong>PASS</strong> 했습니다.</p>\n<p> </p>\n<h3 id=\"phase-2-자막을-요약한-문서를-이용하자\" style=\"position:relative;\"><a href=\"#phase-2-%EC%9E%90%EB%A7%89%EC%9D%84-%EC%9A%94%EC%95%BD%ED%95%9C-%EB%AC%B8%EC%84%9C%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%9E%90\" aria-label=\"phase 2 자막을 요약한 문서를 이용하자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Phase 2. 자막을 ‘요약한 문서’를 이용하자.</h3>\n<p>요약의 방식은 정말 다양합니다.</p>\n<blockquote>\n<ol>\n<li>전체 단순 요약</li>\n<li>각 자막 청크별 요약</li>\n<li>CoD(Chain-of-Dense)</li>\n<li>Semantic Chunking을 이용한 요약</li>\n</ol>\n</blockquote>\n<p>등이 존재하는데 3, 4에 대해 좀 얘기해보고자 합니다.</p>\n<p> </p>\n<h4 id=\"1-cod는-비용적-문제가-크다\" style=\"position:relative;\"><a href=\"#1-cod%EB%8A%94-%EB%B9%84%EC%9A%A9%EC%A0%81-%EB%AC%B8%EC%A0%9C%EA%B0%80-%ED%81%AC%EB%8B%A4\" aria-label=\"1 cod는 비용적 문제가 크다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) CoD는 비용적 문제가 크다.</h4>\n<p>요약 시 놓친 엔티티를 함께 반환하고 반복 요약을 함으로써 요약의 밀집 정도를 높여 가는 CoD는 시간적, 경제적 비용 문제가 큽니다.</p>\n<p>먹방 유튜버를 타겟으로 했기 때문에<br>유튜버가 먹은 음식, 해당 음식점 관련 내용, 음식평 등에 초점에 맞춰 밀집 정도가 높은 요약을 시도할 수 있었지만</p>\n<blockquote>\n<p><strong>문제점</strong>이 있었습니다.</p>\n<ol>\n<li><strong>반복적인 요약으로 인한 비용 문제</strong>가 있었고,</li>\n<li><strong>유튜버의 특정 발화 내용이 많이 사라지는 부분이 굉장히 리스크가 있다</strong>고 판단했습니다. (ex. 존맛탱이라는 표현이 요약에서는 없음)</li>\n</ol>\n</blockquote>\n<p>그래서 이 방법도 <strong>PASS</strong>했습니다.</p>\n<p> </p>\n<h4 id=\"2-semantic-chunking을-이용한-요약은-자막의-시간적-흐름을-무시한다\" style=\"position:relative;\"><a href=\"#2-semantic-chunking%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9A%94%EC%95%BD%EC%9D%80-%EC%9E%90%EB%A7%89%EC%9D%98-%EC%8B%9C%EA%B0%84%EC%A0%81-%ED%9D%90%EB%A6%84%EC%9D%84-%EB%AC%B4%EC%8B%9C%ED%95%9C%EB%8B%A4\" aria-label=\"2 semantic chunking을 이용한 요약은 자막의 시간적 흐름을 무시한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) Semantic Chunking을 이용한 요약은 자막의 시간적 흐름을 무시한다.</h4>\n<p>유사한 자막 청크끼리 묶어서 요약을 하는 방법인데</p>\n<blockquote>\n<p>이 또한 <strong>문제점</strong>이 있었습니다.</p>\n<ol>\n<li><strong>자막의 시간적 흐름을 무시하게 되고</strong></li>\n<li>가장 큰 문제점은 ”<strong>먹방 유튜버가 한 영상에서 여러 음식점을 다녀왔을 경우에 발화 장소가 뒤섞여서 요약이 될 수 있다</strong>“는 점이었습니다.</li>\n</ol>\n</blockquote>\n<p>그래서 이 방법도 <strong>PASS</strong>했습니다…</p>\n<p> </p>\n<h3 id=\"phase-3-contextual-retrieval-anthropic을-이용하자-️\" style=\"position:relative;\"><a href=\"#phase-3-contextual-retrieval-anthropic%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%9E%90-%EF%B8%8F\" aria-label=\"phase 3 contextual retrieval anthropic을 이용하자 ️ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Phase 3. Contextual Retrieval (Anthropic)을 이용하자. ‼️</h3>\n<p>”<strong>자막을 어떻게 활용하고자 하는 것인가</strong>” 본질적인 질문으로 돌아봤습니다.</p>\n<blockquote>\n<p>”<strong>사용자가 입력한 영상의 특정 내용과 연관된 자막 문서를 검색해오는 것</strong>”</p>\n</blockquote>\n<p>그렇다면 자막 문서를 그대로 살리되, 검색의 성능만을 높여야 했습니다.</p>\n<p> </p>\n<p><strong>유튜브의 (자동 생성) 자막의 특성</strong>을 파악해봅시다.</p>\n<blockquote>\n<ol>\n<li><strong>자막은 구어체 중심의 표현이 많으며 불명확한 지시대명사(ex. 이것, 저것)가 많다.</strong></li>\n<li><strong>자막은 시간의 흐름에 따라 상황이 달라진다.</strong></li>\n<li><strong>각 자막 청크에는 어떠한 상황인지 문맥을 파악할 수 있는 내용이 충분하지 않다.</strong></li>\n</ol>\n</blockquote>\n<p> </p>\n<p>그래서 우리가 나아가야 할 방향은<br>아래와 같았습니다.</p>\n<ol>\n<li><strong>불명확한 지칭 표현을 해결하고</strong></li>\n<li><strong>시간의 흐름을 그대로 살리면서</strong></li>\n<li><strong>문맥을 살릴 수 있는 방법을 적용</strong> !!!</li>\n</ol>\n<p>이에… Anthropic에서 2024년도에 발표한</p>\n<p>⭐️ <strong>“Contextual Retrieval”을 적용해보았습니다.</strong> ⭐️</p>\n<p> </p>\n<p>이를 적용한 방법을 바로 얘기해보자면</p>\n<blockquote>\n<ol>\n<li><strong>영상의 자막 전체</strong>와 <strong>문맥을 추가할 자막 청크</strong>를 LLM에게 함께 주어 <strong>전체 맥락을 파악하여 ‘해당 청크의 문맥’을 추가</strong>해달라고 합니다.</li>\n<li>그 이후, <strong>‘문맥 + 기존 청크 내용’을 자막 청크 검색 문서로 사용</strong>합니다.</li>\n</ol>\n</blockquote>\n<p><strong>청킹 방법은 자막의 시간대 한 구간을 묶어서</strong> 하도록 했고,<br><strong>오버랩은 자막 문맥에 들어가지 않도록 metadata에 따로</strong> 넣어두었습니다.</p>\n<p>(필요할 때 프롬프트 템플릿에 따로 꺼내어 쓰고자 합니다.)</p>\n<p> </p>\n<p><strong>‼️ 문맥이 추가된 자막 한 청크 ‼️</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">문맥: 쯔양이 '굽네치킨'의 신메뉴인 맵단짠칩킨을 시식하는 장면입니다.\n그녀는 치킨의 맛이 약간 매콤하면서도 단맛과 짭짤함이 조화를 이루어\n중독성이 강하다고 평가합니다. 특히, 요블링소스에 치킨을 찍어 먹는 방법을\n추천하며, 소스가 치킨의 맛을 한층 더 돋보이게 한다고 말합니다.\n또한, 소스에 찍어 먹는 것이 더욱 맛있다고 강조하며, '굽네'의 소스\n실력이 뛰어나다고 칭찬합니다.\n\n[04:16 ~ 05:11] 막 맵진 않고 약간 매콤한데\\n약간 단맛도 나고\n짭짤한 맛도 나면서\\n(멈출 수 없는 중독적인 맛-!!) 진짜 딱 중독성 있는\n그런 맛이거든요?\\n(뼈도 맛있옹ㅎ)\\n진짜 감칠맛이 어마어마한 그런 맛?\\n\n이번엔 소스에 찍어서!\\n요블링소스에 푹 찍어서 먹어보겠습니다...!\\n\n맛있다\\n이게 약간 맵단짠이잖아요, 그래서\\n요블링소스가 진짜 잘 어울려요\\n\n감사합니다!\\n(1인 2 뼈 통...ㅎ) 2개를ㅋㅋㅋ\\n와, 근데 역시 '굽네'가\n\\n소스를 진짜 잘해요!\\n고추바사삭 먹을 때도 고블링, 마블링소스 찍어\n먹잖아요!\\n이번 소스도!</code></pre></div>\n<ul>\n<li>문맥을 생성할 때에, ”<strong>누가, 무엇을, 어떻게 하는지 문장형식으로 서술히도록 하고, 음식명, 음식점명과 같은 고유명사는 그대로 사용</strong>“하여 생성하도록 했습니다.\n<ul>\n<li>그래서 <strong>“맵단짠’칩’킨”의 고유명사를 그대로 사용하고 있음</strong>을 볼 수 있습니다.</li>\n</ul>\n</li>\n<li>‘문맥’ 아래에 있는 자막에서는 “진짜 감칠맛이 어마어마한 그런 맛”의 <strong>대상이 불명확</strong>했지만<br><strong>전체 자막 맥락을 통해 현재 맵단짠칩킨을 시식하고 있었음을 맥락적으로 확인</strong>하여 서술해주고 있습니다.</li>\n</ul>\n<p> </p>\n<p><strong>‼️ 모델은 오픈소스 소형 모델 ‼️</strong></p>\n<p>자막 텍스트 길이가 너무 길다 보니 <strong>비용 문제</strong>를 신경쓰지 않을 수가 없었습니다.</p>\n<p>한국어를 잘한다는 모델 다양하게 이용해보았습니다.<br>(a.x-4.0-light-imatrix:Q8_0, exaone3.5:7.8b, qwen3:8b, EEVE-Korean-Instruct-10.8B, solar:10.7b-instruct-v1-q5_0 등)</p>\n<p>그 중에 SK텔레콤의 <strong>a.x-4.0-light-imatrix:Q8_0</strong> 모델이 현 데이터에 가장 적합한 모델이었습니다. 👍🏻</p>\n<p> </p>\n<p><strong>인사이트</strong> 💡</p>\n<blockquote>\n<ol>\n<li>\n<p><strong>대화형 데이터는 a.x 모델이 가장 적합하다.</strong></p>\n</li>\n<li>\n<p><strong>오픈소스 소형 모델의 기존 학습된 출력 포맷으로 인해 ‘문맥’만 출력하도록 하는 것이 어렵다.</strong></p>\n</li>\n</ol>\n</blockquote>\n<p>2의 문제에서는</p>\n<p>프롬프트 엔지니어링을 통해 생성한 문맥만 출력하도록 유도를 해보아도<br>“~~는 아래와 같습니다.”과 같은 말과 마크다운 문법 등을 사용하며 그 부분이 지켜지지 않은 경우가 많았습니다.</p>\n<p>그래서, <strong>bullet point, 마크다운 문법 등이 있을 때 출력을 정제하는 후처리 파싱까지 진행</strong>했습니다 ‼️</p>\n<p> </p>\n<p> </p>\n<h2 id=\"두번째-고민-문맥-추가한-것에-관한-rag-평가-설계는-어떻게-할-것인가\" style=\"position:relative;\"><a href=\"#%EB%91%90%EB%B2%88%EC%A7%B8-%EA%B3%A0%EB%AF%BC-%EB%AC%B8%EB%A7%A5-%EC%B6%94%EA%B0%80%ED%95%9C-%EA%B2%83%EC%97%90-%EA%B4%80%ED%95%9C-rag-%ED%8F%89%EA%B0%80-%EC%84%A4%EA%B3%84%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%A0-%EA%B2%83%EC%9D%B8%EA%B0%80\" aria-label=\"두번째 고민 문맥 추가한 것에 관한 rag 평가 설계는 어떻게 할 것인가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>두번째 고민: 문맥 추가한 것에 관한 ‘RAG 평가 설계’는 어떻게 할 것인가?</h2>\n<hr>\n<p>RAGAS 기반으로 평가셋을 우선 만들었습니다. (무작위 32개 영상을 뽑아 자막 청크를 만들었습니다.)</p>\n<p>생성된 평가셋은</p>\n<blockquote>\n<ol>\n<li>정원분식과 떡볶당은 떡볶이와 분위기에서 어떻게 다른가요?</li>\n<li>압구정동 식당의 스테이크 트러플 짜장면이 특별한 이유는 무엇인가요?</li>\n<li>메뉴에 있는 매운 해산물 국수 요리가 무엇인가요?</li>\n</ol>\n</blockquote>\n<p>이런 것들이 있었습니다.</p>\n<p><strong>simple: 0.4</strong>, <strong>reasoning: 0.2</strong>, <strong>multi_context: 0.4</strong>의 비율로 평가셋을 생성했지만<br>전체 맥락적 요소를 파악하지 못한 부분들이 꽤 있었습니다.</p>\n<p> </p>\n<p>이를 기반하여 평가를 진행한 결과,</p>\n<p> </p>\n<h3 id=\"비교-문맥-추가-전-vs-문맥-추가-후\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EA%B5%90-%EB%AC%B8%EB%A7%A5-%EC%B6%94%EA%B0%80-%EC%A0%84-vs-%EB%AC%B8%EB%A7%A5-%EC%B6%94%EA%B0%80-%ED%9B%84\" aria-label=\"비교 문맥 추가 전 vs 문맥 추가 후 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비교: 문맥 추가 전 vs 문맥 추가 후</h3>\n<p>(모두 OpenAI Text-embedding-3-small 임베딩)</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 23.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA6klEQVQY02WQa26DMBCEOQQPA+GRBhkb7ASES5MCht7/UFPtpo1U9cfI8jejndUG67qhbRWkVFCqwzCMeDwWEPf+gPc79v2AtTf27/fPFz+OL0yTY75tHvP8gWBZVh5Cxvn8BilbNqhEKf2U1uxVVQ3n3nG93tjXusPl0jCf5xnjOCKYpgnDMKAoCiRJgrIsYYxBHMeIougl8kh93yPPc4RhyJxySSKglELTNAhoG+ccrLU4nQpUVcUFaZYhTdN/ohyVCiH+cK01pJQIaBip63oO1XXNG2Y8MOP3V/Q3xnJGiPTJfjw6DZ3rG/b/kKICeb5IAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"img 1\" title=\"img 1\" src=\"/static/dd5f84554dd04d9fbb946f3214bf3718/37523/img_1.png\" srcset=\"/static/dd5f84554dd04d9fbb946f3214bf3718/e9ff0/img_1.png 180w,\n/static/dd5f84554dd04d9fbb946f3214bf3718/f21e7/img_1.png 360w,\n/static/dd5f84554dd04d9fbb946f3214bf3718/37523/img_1.png 720w,\n/static/dd5f84554dd04d9fbb946f3214bf3718/d53ff/img_1.png 1068w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<p> </p>\n<p>‼️ <strong>문맥(Context)를 추가한 후에 4가지 평가 지표 모두 많이 상승했습니다.</strong> ‼️</p>\n<p> </p>\n<p>특히</p>\n<p><strong><code class=\"language-text\">Context Precision</code>, <code class=\"language-text\">Faithfulness</code>, <code class=\"language-text\">Context Recall</code> 3가지 지표가 크게 상승했음</strong>을 알 수 있습니다.</p>\n<ol>\n<li><code class=\"language-text\">Context Precision</code>: 검색된 문서들이 실제로 관련 있는 문서들의 비율</li>\n<li><code class=\"language-text\">Faithfulness</code>: LLM이 검색된 Context에 얼마나 충실하게 답변하는지</li>\n<li><code class=\"language-text\">Context Recall</code>: 정답을 생성하기 위해 필요한 정보를 얼마나 잘 검색해왔는지</li>\n</ol>\n<p> </p>\n<p>본 프로젝트의 RAG 개발에서는</p>\n<p><strong>사용자의 입력과 관련한 문서를 ‘많이’, ‘정확히’ 가져오는 것이 중요</strong>해서<br><strong><code class=\"language-text\">Context Precision</code>와 <code class=\"language-text\">Context Recall</code>가 주요한 지표였습니다.</strong></p>\n<p> </p>\n<p>이들이 충분히 크게 개선이 되어<br><strong>문맥을 추가한 자막 문서를 이용하자고 결정</strong>했습니다.</p>\n<p> </p>\n<p> </p>\n<h2 id=\"세번째-고민-rag-성능을-더욱-개선시킬-수-있는-방법은\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EB%B2%88%EC%A7%B8-%EA%B3%A0%EB%AF%BC-rag-%EC%84%B1%EB%8A%A5%EC%9D%84-%EB%8D%94%EC%9A%B1-%EA%B0%9C%EC%84%A0%EC%8B%9C%ED%82%AC-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80\" aria-label=\"세번째 고민 rag 성능을 더욱 개선시킬 수 있는 방법은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세번째 고민: RAG 성능을 더욱 개선시킬 수 있는 방법은?</h2>\n<p>문맥 추가로 4가지 평가 지표를 크게 개선시켰지만<br>가장 낮은 <code class=\"language-text\">Answer Relevancy</code>을 제외하더라도, 50~80점 사이로 다소 아쉬운 성능입니다.</p>\n<p>이에, <strong>앙상블 Retriever</strong>와 <strong>Reranker</strong>을 도입해보고자 합니다.</p>\n<ol>\n<li>\n<p>자막은 <strong>Sparse 벡터 검색도 추가</strong>하여 <strong>하이브리드 방식으로 검색하는 것이 좋을 것</strong>이라 생각했고<br>(특정 음식과 같은 고유명사가 들어간 사용자 입력이 있을 수 있어, 키워드 기반의 검색도 필요해보였습니다.)</p>\n</li>\n<li>\n<p><strong>Cross Encoder 방식인 Reranker를 도입</strong>하는 것이 좋을 것이라 생각했습니다.<br>(좀 더 빠른 ColBERT도 고민해보았지만 본 프로젝트에서는 관련 깊은 문서를 가져오는 것이 더 중요했습니다.)</p>\n</li>\n</ol>\n<p>그렇게 Dense + Sparse 검색과 리랭커를 도입해보았습니다.</p>\n<p> </p>\n<p>여기서는 여러 모델의 테스트를 진행하지 못했습니다.<br>다만, 한국어 잘한다는 BGE 모델을 적극 활용했습니다.</p>\n<ol>\n<li>Dense Vector(OpenAI text-embedding-3-small) + Sparse Vector 검색(BGE-m3) + Reranker(BGE-reranker-v2-m3)</li>\n<li><strong>Dense Vector(BGE-m3l) + Sparse Vector 검색(BGE-m3) + Reranker(BGE-reranker-v2-m3)</strong></li>\n</ol>\n<p>둘을 비교했을 때</p>\n<p>2번째 <strong>Dense Vector(BGE-m3l) + Sparse Vector 검색(BGE-m3) + Reranker(BGE-reranker-v2-m3)</strong> 방식이 더 성능이 좋았습니다.</p>\n<p> </p>\n<p>아까 개선했던</p>\n<p>문맥 있는 자막 문서에서의 성능에서<br><strong>‘앙상블 Retriever+리랭커’를 도입</strong>하면서 <strong>모든 평가 지표에서 추가 개선</strong>되었습니다 ‼️</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 21.666666666666668%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAyUlEQVQY002Oaw6CMBCEOQSPVlJISoECDYZHAUWjQeL9bzSmqyH+mOxmdvbb9dbbHet6w/ncwZgW1s7YthfmecE4Tti2neZOl8tK/uPxxDBYdN2AZbmi70fs+5uqp7VG1/domgZxHCPPc0gp4fs+lFIoigJhGCKKIhJjjOR6IQSqqqK8yznPcyBrLdq2hRAJtK6QZRmCIKSQW3AAzk/gnB9ijCNNUxhj6HBd1+QfwGmaKFCW5Q8YQKmcPnaX/2FfIEOSpASSMjuAH767dApjtgqFAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"img 2\" title=\"img 2\" src=\"/static/7c3a4a33419e47166bd454c93df4437e/37523/img_2.png\" srcset=\"/static/7c3a4a33419e47166bd454c93df4437e/e9ff0/img_2.png 180w,\n/static/7c3a4a33419e47166bd454c93df4437e/f21e7/img_2.png 360w,\n/static/7c3a4a33419e47166bd454c93df4437e/37523/img_2.png 720w,\n/static/7c3a4a33419e47166bd454c93df4437e/302a4/img_2.png 1080w,\n/static/7c3a4a33419e47166bd454c93df4437e/0f246/img_2.png 1118w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n<p> </p>\n<p><code class=\"language-text\">Answer Relevancy</code>를 제외한 지표들은 60~90점 사이의 값을 가지네요.</p>\n<p><strong><code class=\"language-text\">Context Precision</code>와 <code class=\"language-text\">Context Recall</code>가 80점대로 괜찮은 성능이라 판단하여 이 방식을 따르자고 결정했습니다.</strong></p>\n<p> </p>\n<p><strong>인사이트</strong> 💡</p>\n<blockquote>\n<p>”<strong>임베딩 차원이 높다고 항상 성능이 좋은 것은 아니다.</strong>”</p>\n</blockquote>\n<p>BGE-m3 임베딩 모델은 1024차원, OpenAI text-embedding-3-small 임베딩 모델은 1536차원입니다.</p>\n<p>그런데도 BGE-m3 임베딩 모델의 성능이 더 좋았습니다.</p>\n<p>결국 임베딩 차원이 단순히 높은 것보다는, <strong>“한국어에 적합한 임베딩 모델을 선택하는 것”</strong>이 주요해보였습니다.<br></p>\n<p> </p>\n<p> </p>\n<p>해당 프로젝트에서 Agent가 해당 Retriver를 이용하도록 설계할 예정이라 RAG의 성능을 높이는 것이 필요했었습니다.</p>\n<p>지금까지 프로젝트에서 RAG 개발 여정기였습니다.</p>\n<p>끄읕.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%B2%AB%EB%B2%88%EC%A7%B8-%EA%B3%A0%EB%AF%BC-asr-%EC%98%A4%EB%A5%98-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EA%B2%B0%ED%95%98%EC%A7%80\">첫번째 고민: ASR 오류 어떻게 해결하지?</a></p>\n<ul>\n<li>\n<p><a href=\"#phase-1-%EC%9E%90%EB%A7%89-%EA%B5%90%EC%A0%95-%EC%8B%9C%EB%8F%84%ED%95%B4%EB%B3%B4%EC%9E%90\">Phase 1. 자막 교정 시도해보자.</a></p>\n</li>\n<li>\n<p><a href=\"#phase-2-%EC%9E%90%EB%A7%89%EC%9D%84-%EC%9A%94%EC%95%BD%ED%95%9C-%EB%AC%B8%EC%84%9C%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%9E%90\">Phase 2. 자막을 ‘요약한 문서’를 이용하자.</a></p>\n<ul>\n<li><a href=\"#1-cod%EB%8A%94-%EB%B9%84%EC%9A%A9%EC%A0%81-%EB%AC%B8%EC%A0%9C%EA%B0%80-%ED%81%AC%EB%8B%A4\">1) CoD는 비용적 문제가 크다.</a></li>\n<li><a href=\"#2-semantic-chunking%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9A%94%EC%95%BD%EC%9D%80-%EC%9E%90%EB%A7%89%EC%9D%98-%EC%8B%9C%EA%B0%84%EC%A0%81-%ED%9D%90%EB%A6%84%EC%9D%84-%EB%AC%B4%EC%8B%9C%ED%95%9C%EB%8B%A4\">2) Semantic Chunking을 이용한 요약은 자막의 시간적 흐름을 무시한다.</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#phase-3-contextual-retrieval-anthropic%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%9E%90-%EF%B8%8F\">Phase 3. Contextual Retrieval (Anthropic)을 이용하자. ‼️</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%91%90%EB%B2%88%EC%A7%B8-%EA%B3%A0%EB%AF%BC-%EB%AC%B8%EB%A7%A5-%EC%B6%94%EA%B0%80%ED%95%9C-%EA%B2%83%EC%97%90-%EA%B4%80%ED%95%9C-rag-%ED%8F%89%EA%B0%80-%EC%84%A4%EA%B3%84%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%A0-%EA%B2%83%EC%9D%B8%EA%B0%80\">두번째 고민: 문맥 추가한 것에 관한 ‘RAG 평가 설계’는 어떻게 할 것인가?</a></p>\n<ul>\n<li><a href=\"#%EB%B9%84%EA%B5%90-%EB%AC%B8%EB%A7%A5-%EC%B6%94%EA%B0%80-%EC%A0%84-vs-%EB%AC%B8%EB%A7%A5-%EC%B6%94%EA%B0%80-%ED%9B%84\">비교: 문맥 추가 전 vs 문맥 추가 후</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%84%B8%EB%B2%88%EC%A7%B8-%EA%B3%A0%EB%AF%BC-rag-%EC%84%B1%EB%8A%A5%EC%9D%84-%EB%8D%94%EC%9A%B1-%EA%B0%9C%EC%84%A0%EC%8B%9C%ED%82%AC-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80\">세번째 고민: RAG 성능을 더욱 개선시킬 수 있는 방법은?</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"January 30, 2026","title":"[LLM] Contextual Retrieval과 RAG 평가 💡 (feat. RAGAS, 쯔동 프로젝트)","categories":"LLM RAG","author":"변우중","emoji":"☀️"},"fields":{"slug":"/26-01-30_1/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://www.zoomkoding.com","comments":{"utterances":{"repo":"https://github.com/byeonwoojung/byeonwoojung.github.io"}}}}},"pageContext":{"slug":"/26-02-15_1/","nextSlug":"/26-01-30_1/","prevSlug":""}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}